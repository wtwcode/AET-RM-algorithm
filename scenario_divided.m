clear all
clc

% 下面这个矩阵是6个方案(行数)，每个方案6个指标(列数)
ganrao=[3.5	2.666666667
3.416666667	2.583333333
3.166666667	2.416666667
3.666666667	2.75
3.083333333	2.166666667
4	2.416666667
4.25	2.75
4.333333333	3.166666667
3.25	3
3.166666667	2.333333333
2.75	1.916666667
2.333333333	1.5
2.583333333	3.333333333
3.833333333	3.083333333
3.583333333	2.416666667
3.166666667	2.166666667
3.416666667	2.5
2.75	2.75
2.5	2.916666667
2.666666667	2.833333333
4.583333333	3.416666667
3.5	2.583333333
3.25	1.5
2.916666667	1.666666667
3	1.5
3.333333333	1.75
3.416666667	2.166666667
2.333333333	2.916666667
3.083333333	2.333333333
3.5	1.666666667
3.5	3.333333333
2.833333333	2.583333333
3	2.583333333
4.833333333	2.083333333
3.75	2.75
4	2.25
4	2.333333333]
		
    
[rows,cols]=size(ganrao);   % 输入矩阵的大小,rows为对象个数，cols为指标个数
k=1/log(rows);         % 求k


%求比重
% sigma1=sum(ganrao(:,1));
% sigma2=sum(ganrao(:,2));
% 
% PIJ=zeros(rows,cols);
% 
% for I=1:cols
%     sigmaI=sum(ganrao(:,i));
%     for J=1:rows
%         PIJ(J,I)= ganrao(J,I)/sigmaI;
%     end
% end


y = ganrao;

%2 求Y（i,j）
MAX=max(y);
MIN=min(y);
Y = zeros(rows,cols); 
for J=1:cols
    for I=1:rows
        Y(I,J)= (y(I,J)-MIN(J))/(MAX(J)-MIN(J));
    end
end
%% 数据预处理_标准化
Z = Y ./ repmat(sum(Y.*Y) .^ 0.5, rows, 1);
disp('标准化矩阵 Z = ')
disp(Z)
%z1=sum(Z,1);

%% 指标权重赋值
disp("请输入是否需要增加权重向量，需要输入1，不需要输入0")
ahp_w1=[0.2
0.2
0.2
0.2
0.2
0.2
0.08
0.08
0.08
0.08
0.08
0.08
0.08
0.08
0.08
0.08
0.08
0.08
0.08
0.08
0.08
0.08
0.05
0.05
0.05
0.05
0.05
0.33
0.33
0.33
0.33
0.33
0.33
0.33
0.33
0.33
0.33];
ahp_w=ahp_w1(:,1)/sum(ahp_w1,1);
Judge = input('请输入是否需要增加权重： ');
if Judge == 1
    disp(['有多少个指标就输入多少个权重数(权重和为1)，如[0.25,0.25,0.5]']);
    weigh = input(['请输入' num2str(cols) '个权重: ']);
        if abs(sum(weigh) - 1)<0.000001 && size(weigh,1) == 1 && size(weigh,2) == cols   % 这里要注意浮点数的运算是不精准的。
        else
            weigh = input('你输入的有误，请重新输入权重行向量: ');
        end
else
    weigh = ones(1,cols) ./ cols ; %如果不需要加权重就默认权重都相同，即都为1/cols(列数的倒数）
end
% 计算与最大值的距离和最小值的距离，并算出得分
D_P = sum(((Z - repmat(max(Z),rows,1)) .^ 2 ) .* repmat(weigh,rows,1) ,2) .^ 0.5;   % D+ 与最大值的距离向量
D_N = sum(((Z - repmat(min(Z),rows,1)) .^ 2 ) .* repmat(weigh,rows,1) ,2) .^ 0.5;   % D- 与最小值的距离向量
% D_P1=ahp_w.*D_P;
% D_N1=ahp_w.*D_N;1
S = D_N ./ (D_P+D_N);    % 未归一化的得分
disp('最后的得分为：')
%stand_S = D_N1/sum(D_N1)
S_final=ahp_w.*S;
stand_S = S_final / sum(S_final)% 归一化的得分
[sorted_S,index] = sort(stand_S ,'descend')%对得分进行降序排序并返回原来的位置

% o=repmat(max(Z),rows,1);

